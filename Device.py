import logging

import DeviceHelper
import Packet
import PositionHelper
import TimeHelper
import Transmission

logger = logging.getLogger(__name__)


class Device:
    pos_x = 0
    pos_y = 0

    next_time = 0

    tx_interval = 0
    tx_payload  = 0
    tx_rate     = 0
    tx_duration = 0

    # Class initializer
    # id:            The node unique identifier
    # time_mode:     The distribution of the time error (i.e., normal or uniform)
    # tx_interval:   The period that the node will transmit in seconds (i.e., 60 seconds)
    # tx_rate:       The data rate that the node will transmit in bits/second (i.e., 100 bits/second)
    # tx_payload:    The payload that the node will tranmsit in bytes (i.e., 100 bytes)
    # modulation:    The modulation to use (FHSS or not)
    # hop_duration   The duration in ms of frequency hop
    # hop_list:      The list of sequential frequencies to hop
    def __init__(self, device_id=None, time_mode=None, tx_interval=None, tx_rate=None, tx_payload=None,
                 modulation=None, hop_duration=None, hop_list=None):
        assert(id is not None)

        self.device_id = device_id

        self.time_mode   = time_mode
        self.next_time   = 0
        self.tx_interval = tx_interval
        self.tx_payload  = tx_payload
        self.tx_rate     = tx_rate

        self.modulation   = modulation
        self.hop_duration = hop_duration
        self.hop_list     = hop_list
        self.position_hop_list = 0  # current channel to use by the device

        # The list of packets transmitted for frame traceability and results
        self.pkt_list = []
        # NOTE: pkt_list[4] does NOT get pkt number 4, pkt number can be repeated bc it is split into several when FHSS

        # The time in ms that a transmission lasts
        self.tx_header_duration_ms, self.tx_payload_duration_ms = DeviceHelper.DeviceHelper.get_time_on_air(self.modulation, self.tx_rate, self.tx_payload)
        self.tx_frame_duration_ms = self.tx_header_duration_ms + self.tx_payload_duration_ms

        # The off period to comply with duty cycle regulations
        if self.time_mode == 'max-duty':
            duty_cylce = 0.01
            off_period = self.tx_frame_duration_ms * (1. / duty_cylce - 1)
            self.tx_interval = off_period

        # Get the x, y position of the device in the map
        self.pos_x, self.pos_y = PositionHelper.PositionHelper.get_position()

        logger.debug("Created node with id={} and position x={}, y={}.".format(self.device_id, self.pos_x, self.pos_y))

    # Returns number of packets created
    def get_num_frames(self):
        return len(self.pkt_list)

    # Returns a packet with unique id associated to the node
    def create_frame(self, current_time, duration):
        frame = Packet.Frame(owner=self.device_id,
                             number=self.get_num_frames(),
                             duration=duration,
                             modulation=self.modulation,
                             start_time=current_time)
        self.pkt_list.append(frame)
        logger.debug("New packet id={} with duration time={} generated by Node id={} at time={}.".format(frame.number, frame.duration, frame.owner, current_time))
        return frame

    # Returns the device id
    def get_id(self):
        return self.device_id

    # Get the node position
    def get_position(self):
        return self.pos_x, self.pos_y
    
    # Set node position
    def set_position(self, position):
        self.pos_x, self.pos_y = position

    # Returns the time to perform the next action
    def get_next_time(self):
        return self.next_time
    
    # Initializes the node
    def init(self):
        # Generate a time to start transmitting
        # The next time will be a random variable following a 'uniform' or 'normal' distribution
        # CAUTION: DOES NOT check if transmission fits within simulation time
        self.next_time = TimeHelper.TimeHelper.next_time(current_time=0,
                                                         step_time=self.tx_interval,
                                                         mode=self.time_mode)
        logger.debug("Node id={} scheduling at time={}.".format(self.device_id, self.next_time))

    # Performs the scheduled action if required
    def time_step(self, current_time=None, maximum_time=None, sim_grid=None, device_list=None):
        # Check that the current time is the scheduled time
        if current_time == self.next_time:
            logger.debug("Node id={} executing at time={}.".format(self.device_id, self.next_time))

            # Create a list of frames to be transmitted
            frame = self.create_frame(current_time, self.tx_frame_duration_ms)
            if self.modulation == 'FHSS':
                # Frame partition for frequency hopping
                frames, self.position_hop_list = frame.divide_frame(self.hop_list,
                                                                    self.position_hop_list,
                                                                    self.hop_duration,
                                                                    self.tx_header_duration_ms)
                self.pkt_list.pop()
                self.pkt_list.extend(frames)
            else:
                frames = [frame]    # must be a list

            # Transmit
            Transmission.transmit(frames, sim_grid, device_list)

            # Generate a time for the next transmission
            next_time = TimeHelper.TimeHelper.next_time(current_time=current_time + self.tx_frame_duration_ms,
                                                        step_time=self.tx_interval,
                                                        mode=self.time_mode)
            # If there is time for another action, schedule it
            # i.e., check if next transmission fits within simulation time
            if (next_time + self.tx_frame_duration_ms) < maximum_time:
                self.next_time = next_time
                logger.debug("Node id={} scheduling at time={}.".format(self.device_id, self.next_time))




