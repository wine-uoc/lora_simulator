import logging

import Codes
import Packet
import PositionHelper
import TimeHelper
import Transmission

logger = logging.getLogger(__name__)


class Device:
    pos_x = 0
    pos_y = 0

    next_time = 0

    tx_interval = 0
    tx_payload  = 0
    tx_rate     = 0
    tx_duration = 0

    # Class initializer
    # id:            The node unique identifier
    # time_mode:     The distribution of the time error (i.e., normal or uniform)
    # tx_interval:   The period that the node will transmit in seconds (i.e., 60 seconds)
    # tx_rate:       The data rate that the node will transmit in bits/second (i.e., 100 bits/second)
    # tx_payload:    The payload that the node will tranmsit in bytes (i.e., 100 bytes)
    # modulation:    The modulation to use (FHSS or not)
    def __init__(self, device_id=None, time_mode=None, tx_interval=None, tx_rate=None, tx_payload=None,
                 modulation=None, hop_duration=None):
        assert(id != None)

        self.device_id = device_id

        self.time_mode = time_mode
        self.next_time   = 0
        self.tx_interval = tx_interval
        self.tx_payload  = tx_payload
        self.tx_rate     = tx_rate

        self.modulation = modulation
        self.hop_duration = hop_duration
        self.hop_list = []  # The list of sequential frequencies to hop

        self.pkt_list = []  # The list of packets transmitted

        # The time in ms that a transmission lasts
        self.tx_duration_ms = 1000 * (self.tx_payload * 8) / self.tx_rate
        assert self.tx_duration_ms < self.tx_interval

        # Get the x, y position of the device in the map
        self.pos_x, self.pos_y = PositionHelper.PositionHelper.get_position()

        logger.debug("Created node with id={} and position x={}, y={}.".format(self.device_id, self.pos_x, self.pos_y))

    # Returns number of packets created
    def get_num_frames(self):
        return len(self.pkt_list)

    # Returns a packet with unique id associated to the node
    def create_frame(self, current_time):
        packet = Packet.Frame(owner=self.device_id,
                              number=self.get_num_frames(),
                              duration=self.tx_duration_ms,
                              modulation=self.modulation,
                              hop_duration=self.hop_duration,
                              start_time=current_time)
        self.pkt_list.append(packet)
        logger.debug("New packet id={} with duration time={} generated by Node id={} at time={}.".format(packet.number, packet.duration, packet.owner, current_time))
        return packet

    # Returns the device id
    def get_id(self):
        return self.device_id

    # Get the node position
    def get_position(self):
        return (self.pos_x, self.pos_y)
    
    # Set node position
    def set_position(self, position):
        self.pos_x, self.pos_y = position

    # Returns the time to perform the next action
    def get_next_time(self):
        return self.next_time
    
    # Initializes the node
    def init(self):
        # Generate a time to start transmitting
        # The next time will be a random variable following a 'uniform' or 'normal' distribution
        self.next_time = TimeHelper.TimeHelper.next_time(current_time=0,
                                                         step_time=self.tx_interval,
                                                         mode=self.time_mode,
                                                         tx_duration=self.tx_duration_ms)
        logger.debug("Node id={} scheduling at time={}.".format(self.device_id, self.next_time))

        # Choose a hopping_sequence
        if self.modulation == 'FHSS':
            self.hop_list = Codes.Codes.get_hopping_sequence(self.device_id)

    # Performs the scheduled action if required
    def time_step(self, current_time=None, maximum_time=None, sim_grid=None):
        # Check that the current time is the scheduled time
        if current_time == self.next_time:
            logger.debug("Node id={} executing at time={}.".format(self.device_id, self.next_time))

            # Create packet
            frame = self.create_frame(current_time)

            # Transmit
            Transmission.transmit(frame, sim_grid)

            # Generate a time for the next transmission
            next_time = TimeHelper.TimeHelper.next_time(current_time=current_time,
                                                        step_time=self.tx_interval,
                                                        mode=self.time_mode,
                                                        tx_duration=self.tx_duration_ms)
            
            # If there is time for another action, schedule it
            # i.e., check if next transmission fits within simulation time
            if (next_time + self.tx_duration_ms) < maximum_time:
                self.next_time = next_time
                logger.debug("Node id={} scheduling at time={}.".format(self.device_id, self.next_time))

