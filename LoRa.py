import logging

import numpy
from Device import Device
from Frame import Frame
import numpy as np

import math

logger = logging.getLogger(__name__)

class LoRa(Device):
    
    def __init__(self, dev_id, data_rate, payload_size, interval, time_mode, packet_loss_threshold, position, tx_power, gateway, auto_dr):
        """Initializes LoRa device

        Args:
            dev_id (int): device id
            data_rate (int): LoRa data rate mode
            payload_size (int): payload size
            interval (int): Transmit interval for this device (ms).
            time_mode (str): Time error mode for the transmitting device
            packet_loss_threshold (float): Packet loss threshold.
            position (tuple(float, float, float)): Position of the device in the map.
            tx_power (int): TX power of the device (dBm).
            gateway (Gateway): gateway instance for auto DR selection.
            auto_dr (bool): Whether LoRa data rate mode selection is automatic or not.
        """
        super().__init__(dev_id, data_rate, payload_size, interval, time_mode, packet_loss_threshold, position, tx_power, gateway, auto_dr)
        (self.__tx_frame_duration_ms,
         self.__tx_header_duration_ms,
         self.__tx_payload_duration_ms
        ) = self._compute_toa()

        self.interval = self._get_off_period(t_air=self.__tx_frame_duration_ms, dc=0.01)
        self.next_time = None
       
    
    def create_frame(self):
        """Creates a Frame to be transmitted

        Returns:
            [Frame]: frame instance in a list
        """
        owner = self.dev_id
        number = self.get_frame_dict_length()
        duration = self.__tx_header_duration_ms + self.__tx_payload_duration_ms
        start_time = self.next_time
        frame = Frame(
                    dr         = self.modulation.get_data_rate(),
                    lost       = self.rx_power < self.modulation.rx_sensitivity[self.sf - 7],
                    owner      = self.dev_id,
                    number     = self.get_frame_dict_length(),
                    duration   = self.__tx_header_duration_ms + 
                                 self.__tx_payload_duration_ms,
                    start_time = self.next_time,
                    rx_power   = self.rx_power
                    )

        logger.debug("New packet id={} with duration time={} generated by Node id={} at time={}.".format(number,
                                                                                                         duration,
                                                                                                         owner,
                                                                                                         start_time))
    
        #save them into self.frame_dict
        if number not in self.frame_dict:
            self.frame_dict[number] = []
            
        self.frame_dict[number].append(frame)

        #return created frame
        return [frame]

    def calculate_metrics(self):
        """Calculate metrics.

        Count frames and how many of them were collided.

        Returns:
            (int, int): (frames_count, collisions_count)
        """
        frames = self.frame_dict.values()
        frames_list = sum(frames, [])
        # how many of them collided
        collided_count = 0

        #DONE: 1-comprobar que rx_power de pkt sea mayor que la sensibilidad (varÃ­a segun SF). Si no, se descarta.
        #      2-comprobar que el paquete se recibe con una SINR suficiente.

        for pkt in frames_list:
            logger.debug(f'Processing LoRa frame: ({pkt.get_owner()},{pkt.get_number()},{pkt.get_part_num()})...........................................................')
            sig_sf = self.sf 
            #Check if pkt is lost 
            if pkt.is_lost():
                # Packet received with too small power. Consider it lost.
                logger.debug(f'Frame is LOST!')
                collided_count += 1
            else:
                # Packet received with enough power.
                logger.debug(f'Frame is RECEIVED!')
                if not pkt.get_is_collided():
                    logger.debug(f'Frame is NOT collided!')
                else:
                    #pkt collides with some other frame(s)
                    logger.debug(f'Frame is collided!')
                    coll_frames = pkt.get_collided_frames()
                    sig_time = pkt.get_duration() / 1000 # in sec
                    sig_power = (10**(pkt.get_rx_power()/10)) / 1000 # in W
                    sig_energy = sig_time * sig_power
                    #array to accumulate energy of each interfering frame by SF
                    cumulative_int_energy = [[0.0, []] for _ in range(0,6)]
                    
                    # Check all interfering frames with pkt and stores interference energy from each one.
                    visited_frames = [pkt] # frames already visited (initially only pkt)
                    to_visit_frames = coll_frames # frames to be visited (initially all frames that collide with pkt)
                    while len(to_visit_frames) != 0: 
                        #if not int_frame.is_lost():
                        int_frame = to_visit_frames[0]
                        int_time = pkt.get_time_colliding_with_frame(int_frame) / 1000 # in sec
                        to_visit_frames.pop(0) # int_frame already visited
                        if int_time != 0:
                            # int_frame actually collides with pkt. Store its energy according to collision duration.
                            visited_frames.append(int_frame) # add int_frame into visited_frames list
                            int_frame_sf = 12 - int_frame.get_data_rate()
                            int_frame_power = (10**(int_frame.get_rx_power() / 10.0)) / 1000 # in W
                            int_frame_energy = int_time * int_frame_power
                            cumulative_int_energy[int_frame_sf - 7][0] += int_frame_energy
                            cumulative_int_energy[int_frame_sf - 7][1].append(int_frame)
                            to_visit_frames.extend([frame for frame in int_frame.get_collided_frames() if frame not in visited_frames and not frame.is_lost()]) #
                    
                    visited_frames.sort(key=lambda f: f.get_start_time())
                    # Since receiver locks to a frame, pkt will only be received if it arrives earlier than its interferer frames.
                    if visited_frames[0] == pkt:
                        # pkt is the first frame of all frames colliding with it.
                        # Store SFs that destroy pkt. It allows us to find out how many bits from pkt are corrupted.
                        destructive_sf = []
                        for currSf in range(7,13):
                            sinr_isolation = self.modulation.sinr[sig_sf - 7][currSf - 7]
                            if cumulative_int_energy[currSf - 7][0] != 0:
                                sinr = 10 * np.log10(sig_energy / cumulative_int_energy[currSf - 7][0]) # in dB
                            else:
                                sinr = np.inf
                            if sinr >= sinr_isolation:
                                logger.debug(f'Frame survived interference with SF{currSf}')
                            else:
                                destructive_sf.append(currSf)
                                logger.debug(f'Frame destroyed by interference with SF{currSf}')

                        #Calculate the amount of time pkt is actually colliding.
                        actual_coll_frames = []
                        for sf in destructive_sf:
                            actual_coll_frames += cumulative_int_energy[sf - 7][1]

                        actual_coll_time = pkt.get_time_colliding_with_frames(actual_coll_frames)

                        collided_ratio = actual_coll_time / pkt.get_duration()
                        if collided_ratio > self.packet_loss_threshold:
                            logger.debug('Frame DESTROYED!')
                            collided_count += 1
                        else:
                            logger.debug('Frame RECOVERED!')
                    
                    else:
                        # There is another frame colliding with pkt that arrives earlier. Therefore, pkt data is not recoverable.
                        collided_count += 1

            
        return (len(self.frame_dict), collided_count)

    def get_next_tx_time(self):
        """Gets next tx time

        Returns:
            int: next tx time
        """
        return self.next_time

    def _compute_toa(self):
        """Computes LoRa devices transmissions time on air 

        Raises:
            Exception: Unknown data rate mode

        Returns:
            (int, int, int): (tx_frame_duration, tx_header_duration, tx_payload_duration) in ms
        """
        # Convert LORA mode to SF
        if (self.data_rate < 0 or self.data_rate > 5):
            raise Exception("Unknown DR mode.")
        else:
            self.sf = 12 - self.data_rate            
        
        # Using default LoRa configuration
        bw = 125            # or 250 [kHz]
        n_preamble = 8      # or 10 preamble length [sym]
        header = True
        cr = 1              # CR in the formula 1 (default) to 4
        crc = True          # CRC for up-link
        IH = not header     # Implicit header
        if (self.sf == 6): 
            # implicit header only when SF6
            IH = True

        # Low Data Rate Optimization
        DE = (bw == 125 and self.sf >= 11)

        r_sym = (bw * 1000) / (2 ** self.sf)
        t_sym = 1. / r_sym * 1000                   # [ms]
        t_preamble = (n_preamble + 4.25) * t_sym    # [ms]

        beta = math.ceil(
            (8 * self.payload_size - 4 * self.sf + 28 + 16 * crc - 20 * IH) / (4 * (self.sf - 2 * DE))
        )
        n_payload = 8 + max(beta * (cr + 4), 0)
        t_payload = n_payload * t_sym

        hdr_reps = self.modulation.get_num_hdr_replicas()

        return hdr_reps * round(t_preamble + t_payload), round(t_preamble), round(t_payload)

    def generate_next_tx_time(self, current_time, maximum_time):
        """Generates the next tx time

        Args:
            current_time (int): lower bound instant of time
            maximum_time (int): upper bound instant of time

        Returns:
            int: instant of time between current_time and maximum_time
        """
        next_time = super().generate_next_tx_time(current_time)
        if (next_time + self.__tx_frame_duration_ms < maximum_time):
            self.next_time = next_time
        else:
            self.next_time = numpy.inf
            
        return self.next_time